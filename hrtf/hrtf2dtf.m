function [dtf,ctf]=hrtf2dtf(hrtf,varargin)
%HRTF2DTF extracts DTFs (and CTFs) from an HRTF set
%   Usage:      [dtf,ctf]=hrtf2dtf(hrtf)
%               [dtf,ctf]=hrtf2dtf(hrtf,f1,f2)
%
%   Input parameters:
%     hrtf:     complete hrtf data object in SOFA format
%               (SimpleFreeFieldHRIR convention)
%
%   Output arguments:
%     dtf:      SOFA object of the directional transfer functions
%     ctf:      SOFA object of the common transfer functions (similar 
%               across source positions)
%
%   `hrtf2dtf(...)` calculates directional transfer functions (DTFs) using 
%   the method from Majdak et al. (2010), which is similar to the procedure 
%   of Middlebrooks (1999a). 
%   The magnitude of the common transfer function (CTF) is calculated by   
%   averaging the log-magnitude spectra across all HRTFs for each subject  
%   and ear. The phase spectrum of the CTF is set to the minimum phase 
%   corresponding to the amplitude spectrum of the CTF. Then, the DTFs result 
%   from filtering the HRTFs with the inverse complex CTF. 
%
%   `hrtf2dtf` accepts the following optional parameters:
%
%     'f1',f1     lower frequency bound; default: 50 Hz
%     'f2',f2     upper frequency bound; default: 18 kHz
%     'atten',a   broadband attenuation in order to avoid clipping;
%                 default: 20 dB
%
%   References: majdak2010methods middlebrooks1999scaling

% Author: Robert Baumgartner, 13.01.2014

definput.keyvals.f1 = 50;     % Hz
definput.keyvals.f2 = 18000;  % Hz
definput.keyvals.atten = 20;  % dB

[flags,kv]=ltfatarghelper({'f1','f2','atten'},definput,varargin);

kv.fs = hrtf.Data.SamplingRate;
hrtfmtx = shiftdim(hrtf.Data.IR,2); % dim 1: time, dim 2: source position, dim 3: receiver/ear
N = size(hrtfmtx,1);
Nfft = 2^nextpow2(N);

% Frequency bounds
df = kv.fs/Nfft;
f = 0:df:kv.fs-df;
idx = f >= kv.f1 & f <= kv.f2;
idx(Nfft/2+2:end) = fliplr(idx(2:Nfft/2));

%% CTF calculation
hrtff=fft(hrtfmtx,Nfft);
ctfflog=mean(log(abs(hrtff)),2);

% Force minimum phase 
ctfcep = ifft(ctfflog,Nfft);
ctfcep(Nfft/2+2:Nfft) = 0;    % flip acausal part to causal part or multiply
ctfcep(2:Nfft/2) = 2*ctfcep(2:Nfft/2);    % causal part by 2 (due to symmetry)
ctfflog = fft(ctfcep,Nfft);
ctff = exp(ctfflog);
ctfmtx = ifft(ctff,Nfft);

%% DTF calculation
dtff = hrtff;
dtff(idx,:,:) = hrtff(idx,:,:)./repmat(ctff(idx,:,:),[1 size(hrtff,2) 1]);
dtfmtx = ifft(dtff,Nfft);

%% Attenuate to avoid clipping
ctfmtx = ctfmtx / 10^(kv.atten/20);
dtfmtx = dtfmtx / 10^(kv.atten/20);

%% Output Objects
dtf = hrtf;
dtf.Data.IR = shiftdim(dtfmtx,1);
dtf.GLOBAL_Comment = [dtf.GLOBAL_Comment '. Directional transfer functions (DTFs) were generated by removing from the HRTFs the direction-independent log-amplitude spectrum for each ear.'];

ctf = hrtf;
ctf.Data.IR = shiftdim(ctfmtx,1);
ctf.GLOBAL_Comment = [dtf.GLOBAL_Comment '. Common transfer functions (CTFs) were extracted from the HRTFs in terms of averaging the log-amplitude spectrum for each ear. The phase of a CTF is determined as minimum phase.'];
ctf.SourcePosition = [0 0 0];
ctf.MeasurementSourceAudioChannel = 0;
ctf.MeasurementAudioLatency = [0 0];
ctf = SOFAupdateDimensions(ctf);

end
